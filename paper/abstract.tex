\documentclass[12pt]{article}
\usepackage{a4}
\usepackage[margin=.5cm,bottom=1.5cm]{geometry}

\usepackage[utf8]{inputenc}

\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage{comment}
\usepackage{mathpartir}
\usepackage{stmaryrd} % llbracket, rrbracket
\usepackage{listings}
\lstset{
  mathescape=true,
  language=[Objective]{Caml},
  basicstyle=\ttfamily,
  extendedchars=true,
  showstringspaces=false,
  aboveskip=\smallskipamount,
  % belowskip=\smallskipamount,
  columns=fullflexible,
  moredelim=**[is][\color{blue}]{/*}{*/},
  moredelim=**[is][\color{green!60!black}]{/!}{!/},
  moredelim=**[is][\color{orange}]{/(}{)/},
  moredelim=[is][\color{red}]{/[}{]/},
  xleftmargin=1em,
}
\lstset{aboveskip=0.4ex,belowskip=0.4ex}

\usepackage{notations}

\title{Translation validation of a pattern-matching compiler}
\author{Francesco Mecca, Gabriel Scherer}

\begin{document}
\maketitle

\begin{abstract}
We propose an algorithm for the translation validation of a pattern
matching compiler for a small subset of the OCaml pattern
matching features. Given a source program and its compiled version the
algorithm checks wheter the two are equivalent or produce a counter
example in case of a mismatch.

Our equivalence algorithm works with decision trees. Source patterns are
converted into a decision tree using matrix decomposition.
Target programs, described in a subset of the Lambda intermediate
representation of the OCaml compiler, are turned into decision trees
by applying symbolic execution.
\end{abstract}
\section{Translation validation}
A pattern matching compiler turns a series of pattern matching clauses
into simple control flow structures such as \texttt{if, switch}, for example:

\begin{minipage}{0.3\linewidth}
\begin{lstlisting}
  match li with
  | [] -> (0, None)
  | x::[] -> (1, Some x)
  | _::y::_ -> (2, Some y)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.7\linewidth}
\begin{lstlisting}
(if li
    (let (tl =a (field 1 li))
        (if tl
            (let (y =a (field 0 tl))
                (makeblock 0 2 (makeblock 0 y)))
            (let (x =a (field 0 li))
                (makeblock 0 1 (makeblock 0 x)))))
    (makeblock 0 0 0a))
\end{lstlisting}
\end{minipage}

The code on the right is in the Lambda intermediate representation of
the OCaml compiler. The Lambda representation of a program is shown by
calling the \texttt{ocamlc} compiler with \texttt{-drawlambda} flag.

The pattern matching compiler is a critical part of the compiler
in terms of correctness because bugs typically result in wrong code
production rather than compilation failures.
Such bugs also are hard to catch by testing because they arise in
corner cases of complex patterns which are typically not in the
compiler test suite or most user programs.
In the last five years there were (only) two known bugs in the OCaml pattern
matching compiler; they resulted in silent wrong-code production,
and were found long after they were introduced.

We would like to keep evolving the pattern matching compiler, either by
using a new algorithm or by incremental refactorings.
We want to verify the changed compiler to ensure that no bugs were
introduced.

One could either verify the compiler implementation
(full verification) or check each input-output pair
(translation validation). We chose translation validation; it gives
a weaker result but is much easier to adopt in a production
compiler. The compiler is treated as a blackbox and proof only depends
on our equivalence algorithm between source and target programs.

\section{Our approach}

%% replace common TODO
Our algorithm translates both source and target programs into a common
representation, \emph{decision trees}. Here are the decision tree for the
source and target example programs.

~

\begin{minipage}{0.4\linewidth}
\begin{verbatim}
       Switch(Root)
       /        \
     (= [])    (= ::)
     /             \
   Leaf         Switch(Root.1)
(0, None)       /         \
             (= [])      (= ::)
             /               \
          Leaf              Leaf
   [x = Root.0]         [y = Root.1.0]
   (1, Some x)          (2, Some y)
\end{verbatim}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
\begin{verbatim}
       Switch(Root)
       /        \
     (= int 0)  (!= int 0)
     /             \
   Leaf         Switch(Root.1)
(makeblock 0     /       \
  0 0a)         /         \
             (= int 0)    (!= int 0)
             /               \
          Leaf              Leaf
[x = Root.0]            [y = Root.1.0]
(makeblock 0            (makeblock 0
  1 (makeblock 0 x))      2 (makeblock 0 y))
\end{verbatim}
\end{minipage}

~

\texttt{Root.0} is an \emph{accessor}, it represents the
access path to a value that can be reached by deconstructing the
scrutinee (\texttt{li} in our example), in this case the first
subvalue of the scrutinee.

The nodes of condition trees branch on a condition on the accessor;
source conditions test the head constructor of the accessor, whereas
target conditions test the low-level representation of values in
Lambda code. For example, cons cells \texttt{x::xs} or tuples
\texttt{(x,y)} are heap blocks (with tag 0), while the empty list
\texttt{[]} is the immediate integer \texttt{0}.

In this simple example, the two decision trees perform exactly the
same checks in the same order, so the equivalence is obvious. However,
this may not be the case in general, as the compiler may reorder
checks, simplify away redundant checks or sometimes add them to reduce
code size.
%
In the rest of this document we give an overview of our equivalence
algorithm.

% To check the equivalence of a source and a target decision tree,
% we proceed by case analysis.
% %
% If we have two leaves, we check that the target right-hand-side is the
% compilation of the source right-hand-side, and that the captured
% environments are identical over their free variables.
% %
% If we have a node $N$ and another tree $T$ we check equivalence for
% each child of $N$. A child is a pair of a branch condition $\pi_i$ and a
% subtree $C_i$. For every child $(\pi_i, C_i)$ we reduce $T$ by killing all
% the branches that are incompatible with $\pi_i$ and check that the
% reduced tree is equivalent to $C_i$.

\paragraph{Contributions} We have chosen a simple subset of the OCaml
language and implemented a prototype equivalence checker along with
a formal statement of correctness and proof sketches.

Our source language supports integers, lists, tuples and algebraic
datatypes. Patterns support wildcards, constructors and literals,
or-patterns $(p_1 | p_2)$ and pattern variables.  We also support
\texttt{when} guards, which are interesting as they introduce the
evaluation of expressions during matching.

\section{Decision trees, formally}

We will use, but not define by lack of space, the notion of source and
target \emph{programs} $t_S$ and $t_T$, and \emph{expressions} $e_S$
and $e_T$. A source program $t_S$ is a list of pattern-matching clauses
(with an optional \texttt{when}-guard) of the form
\lstinline{| $p$ (when $e_S$)? -> $e_S$}, and a target program $t_T$ is a series
of control-flow conditionals and variable bindings in Lambda code,
with arbitrary Lambda-code expressions $e_T$ at the leaves.
%
We assume given an equivalence relation $\erel {e_S} {e_T}$ on leaf
expressions. In our translation-validation setting, it suffices to
relate each source expression to its compiled form -- the compiler
gives/computes this relation. We have to lift this relation on leaves
into an equivalence procedure for (pattern-matching) programs.

The parametrized grammar $C(\pi, e)$ describes the common structure of
source and decision trees. We use $\pi$ for the \emph{conditions} on
each branch, and $e$ for the expressions in source and target
programs.

%TODO [Gabriel] rename C (Constraint trees) into D (Decision trees).
\begin{mathpar}
  \begin{array}{l@{~}r@{~}r@{~}l}
    \text{\emph{decision trees}} & C(\pi, e)
    & \bnfeq & \Leaf \sigma e \\
    & & \bnfor & \Failure \\
    & & \bnfor & \Switch a {\Fam {i \in I} {\pi_i, C_i}} \Cfb \\
    & & \bnfor & \Guard e {C_0} {C_1} \\
    \text{\emph{accessors}} & a
    & \bnfeq & \Root \;\bnfor\; a.n \quad (n \in \mathbb{N}) \\
    \text{\emph{environment}} & \sigma
    & \bnfeq & [x_1 \mapsto a_1, \dots, x_n \mapsto a_n]
  \end{array}

  \begin{array}{l}
  C_S \bnfeq C(\pi_S, e_S)
  \\
  \pi_S : \text{datatype constructors}
  \\[1em]
  C_T \bnfeq C(\pi_T, e_T)
  \\
  \pi_T \subseteq        \{ \Int n \mid n \in \mathbb{Z} \}
                  \uplus \{ \Tag n \mid n \in \mathbb{N} \}
  \\[1em]
  \text{\emph{matching result}}\quad r ~\bnfeq~ \NoMatch \bnfor \Match \sigma e
  \end{array}
\end{mathpar}

The tree $\Leaf \sigma e$ returns an expression $e$ in a captured
environment $\sigma$. (Environments map the free variables of the
expression to accessors of the scrutinee.)
%
$\Failure$ expresses match failure, when no clause matches the input
value.
%
$\Switch a {\Fam {i \in I} {\pi_i, C_i}} \Cfb$ has one subtree $C_i$
for every head constructor that appears in the pattern matching
clauses, and a fallback case for the constructors.
%
$\Guard e {C_0} {C_1}$ represents a \texttt{when}-guard on an
expression $e$, expected to be of boolean type, with sub-trees $C_0$
for the \texttt{true} case and $C_1$ for the \texttt{false} case.

(Not detailed for reasons of space:) We also have grammars $v_S$ and
$v_T$ for source and target values, and define a relation
$\vrel {v_S} {v_T}$ to relate a source to a target value; this
relation captures our knowledge of the OCaml value representation, for
example it relates the empty list constructor \texttt{[]} to
$\Int 0$. We can then define what it means to ``run'' a value against
a program or a decision, written $t(v)$ and $C(v)$, which gives
a \emph{matching result} $r$.

\section{From source programs to decision trees}

We write $\sem{t_S}_S$ for the decision tree of the source program
$t_S$, computed by a matrix decomposition algorithm (each column
decomposition step gives a \texttt{Switch} node).
It satisfies the following correctness statement:
\[
\forall t_S, \forall v_S, \quad t_S(v_S) = \sem{t_S}_S(v_S)
\]
Running any source value $v_S$ against the source program gives the
same result as running it against the decision tree.

% TODO [Gabriel]: if there is space, it would make sense to mention
% the correctness condition for the decision tree of a matrix, which
% is less immediate than the one for whole programs and may be
% appreciated by the reviewers.

\section{From target programs to decision trees}
The target programs include the following Lambda constructs:
\texttt{let, if, switch, Match\_failure, catch, exit, field} and
various comparison operations, guards. The symbolic execution engine
traverses the target program and builds an environment that maps
variables to accessors. It branches at every control flow statement
and emits a \texttt{Switch} node. The branch condition $\pi_i$ is expressed as
an interval set of possible values at that point.
%
Guards result in branching on the boolean result.
%
In comparison with the source decision trees, \texttt{Unreachable}
nodes are never emitted.

We write $\sem{t_T}_T$ for the decision tree of the target program
$t_T$, satisfying the following correctness statement:
\[
\forall t_T, \forall v_T, \quad t_T(v_T) = \sem{t_T}_T(v_T)
\]

\section{Equivalence checking}
The equivalence checking algorithm takes as input a domain of
possible values \emph{S} and a pair of source and target decision trees and
in case the two trees are not equivalent it returns a counter example.
The algorithm respects the following correctness statement:

% TODO: we have to define what \covers mean for readers to understand the specifications
% (or we use a simplifying lie by hiding \covers in the statements).

\begin{align*}
 \Equiv S {C_S} {C_T} \emptyqueue = \Yes \;\land\; \covers {C_T} S
 & \implies
 \forall v_S \approx v_T \in S,\; C_S(v_S) = C_T(v_T)
\\
 \Equiv S {C_S} {C_T} \emptyqueue = \No {v_S} {v_T} \;\land\; \covers {C_T} S
 & \implies
 v_S \approx v_T \in S \;\land\; C_S(v_S) \neq C_T(v_T)
\end{align*}

% TODO: [Gabriel] I think that the explanation below could be more
% clearly presented as inference rules, I may try to make a proposal
% later.

The algorithm proceeds by case analysis.
If $S$ is empty the results is $\Yes$.
If the two decision trees are both terminal nodes the algorithm checks
for content equality.
If the source decision tree (left hand side) is a terminal while the
target decistion tree (right hand side) is not, the algorithm proceeds
by \emph{explosion} of the right hand side. Explosion means that every
child of the right hand side is tested for equality against the left
hand side.

% TODO: [Gabriel] in practice the $dom_S$ are constructors and the
% $dom_T$ are domains. Do we want to hide this fact, or be explicit
% about it? (Maybe we should introduce explicitly/clearly the idea of
% target domains at some point).

When the left hand side is not a terminal, the algorithm explodes the
left hand side while trimming every right hand side subtree. Trimming
a left hand side tree on an interval set $dom_S$ computed from the right hand
side tree constructor means mapping every branch condition $dom_T$ (interval set of
possible values) on the left to the intersection of $dom_T$ and $dom_S$ when
the accessors on both side are equal, and removing the branches that
result in an empty intersection. If the accessors are different,
\emph{$dom_T$} is left unchanged.

The equivalence checking algorithm deals with guards by storing a
queue. A guard blackbox is pushed to the queue whenever the algorithm
encounters a Guard node on the right, while it pops a blackbox from
the queue whenever a Guard node appears on the left hand side.
The algorithm stops with failure if the popped blackbox and the and
blackbox on the left hand Guard node are different, otherwise in
continues by exploding to two subtrees, one in which the guard
condition evaluates to true, the other when it evaluates to false.
Termination of the algorithm is successful only when the guards queue
is empty.

\begin{comment}

  ------------------------
  equiv \emptyset Cs Ct gs

  --------------------------
  equiv S Failure Failure []

  equiv_BB BBs BBt
  -------------------------------
  equiv S (Leaf BBs) (Leaf BBt) []

  Cs \in (Leaf BBs, Failure)
  (equiv S Cs Ci gs)^i
  equiv S Cs Cf gs
  -----------------------------------------
  equiv S Cs (Node(a, (Domi,Ci)^i, Cf)) gs

  equiv S Ci (trim Ct a=Ki) gs
  equiv S Cf (trim Ct (a\notin(K_i)^i) gs
  -------------------------------------
  equiv S (Node(a, (Ki,Ci)^i, Cf) Ct gs

  equiv S Ctrue Ct (gs++[condition])
  equiv S Cfalse Ct (gs++[condition])
  --------------------------------------------
  equiv S (Guard condition Ctrue Cfalse) Ct gs

  equiv S Cs Ctrue gs
  equiv S Cs Cfalse gs
  --------------------------------------------
  equiv S Cs (Guard condition Ctrue Cfalse) ([condition]++gs)
  
\end{comment}

% TODO integrate the rules below to the text of this section

Our equivalence-checking algorithm $\Equiv S {C_S} {C_T} G$ is
a exactly decision procedure for the provability of the judgment
$(\Equivrel S {C_S} {C_T} G)$, defined below.
\begin{mathpar}
  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{boolean result}} \\
    b & \in & \{ 0, 1 \} \\[0.5em]
    & & \text{\emph{guard queues}} \\
    G & \bnfeq & (t_1 = b_1), \dots, (t_n = b_n) \\
  \end{array}

  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{input space}} \\
    S & \subseteq & \{ (v_S, v_T) \mid \vrel {v_S} {v_T} \} \\
  \end{array}
  \\
  \infer{ }
  {\Equivrel \emptyset {C_S} {C_T} G}

  \infer{ }
  {\Equivrel S \Failure \Failure \emptyqueue}

  \infer
  {\erel {t_S} {t_T}}
  {\Equivrel S {\Leaf {t_S}} {\Leaf {t_T}} \emptyqueue}

  \infer
  {\forall i,\;
    \Equivrel
      {(S \land a = K_i)}
      {C_i} {\trim {C_T} {a = K_i}} G
   \\
   \Equivrel
     {(S \land a \notin \Fam i {K_i})}
     \Cfb {\trim {C_T} {a \notin \Fam i {K_i}}} G
  }
  {\Equivrel S
    {\Switch a {\Fam i {K_i, C_i}} \Cfb} {C_T} G}

  % TODO explain somewhere why the judgment is not symmetric:
  % we avoid defining trimming on source trees, which would
  % require more expressive conditions than just constructors
  \infer
  {C_S \in {\Leaf t, \Failure}
   \\
   \forall i,\; \Equivrel {(S \land a \in D_i)} {C_S} {C_i} G
   \\
   \Equivrel {(S \land a \notin \Fam i {D_i})} {C_S} \Cfb G}
  {\Equivrel S
    {C_S} {\Switch a {\Fam i {D_i} {C_i}} \Cfb} G}

  \infer
  {\Equivrel S {C_0} {C_T} {G, (e_S = 0)}
   \\
   \Equivrel S {C_1} {C_T} {G, (e_S = 1)}}
  {\Equivrel S
    {\Guard {e_S} {C_0} {C_1}} {C_T} G}

  \infer
  {\erel {e_S} {e_T}
   \\
   \Equivrel S {C_S} {C_b} G}
  {\Equivrel S
    {C_S} {\Guard {e_T} {C_0} {C_1}} {(e_S = b), G}}
\end{mathpar}

\end{document}

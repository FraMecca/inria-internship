\documentclass[12pt]{article}
\usepackage{a4}
\usepackage[margin=.5cm,bottom=1.5cm]{geometry}

\usepackage[utf8]{inputenc}

\usepackage{amsmath}

\usepackage{comment}
\usepackage{mathpartir}
\usepackage{stmaryrd} % llbracket, rrbracket
\usepackage{listings}
\lstset{
  mathescape=true,
  language=[Objective]{Caml},
  basicstyle=\ttfamily,
  extendedchars=true,
  showstringspaces=false,
  aboveskip=\smallskipamount,
  % belowskip=\smallskipamount,
  columns=fullflexible,
  moredelim=**[is][\color{blue}]{/*}{*/},
  moredelim=**[is][\color{green!60!black}]{/!}{!/},
  moredelim=**[is][\color{orange}]{/(}{)/},
  moredelim=[is][\color{red}]{/[}{]/},
  xleftmargin=1em,
}
\lstset{aboveskip=0.4ex,belowskip=0.4ex}

\usepackage{notations}

\title{Translation validation of a pattern-matching compiler}
\author{Francesco Mecca, Gabriel Scherer}

\begin{document}
\maketitle

\begin{abstract}
We propose an algorithm for the translation validation of a pattern
matching compiler for a small subset of the OCaml pattern
matching features. Given a source program and its compiled version the
algorithm checks wheter the two are equivalent or produce a counter
example in case of a mismatch.

Our equivalence algorithm works with decision trees. Source patterns are
converted into a decision tree using matrix decomposition.
Target programs, described in a subset of the Lambda intermediate
representation of the OCaml compiler, are turned into decision trees
by applying symbolic execution.
\end{abstract}
\section{Translation validation}
A pattern matching compiler turns a series of pattern matching clauses
into simple control flow structures such as \texttt{if, switch}, for example:

\begin{minipage}{0.3\linewidth}
\begin{lstlisting}
  match li with
  | [] -> (0, None)
  | x::[] -> (1, Some x)
  | _::y::_ -> (2, Some y)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.7\linewidth}
\begin{lstlisting}
(if li
    (let (tl =a (field 1 li))
        (if tl
            (let (tltl =a (field 1 tl)
                  x =a (field 0 tl))
                (makeblock 0 2 (makeblock 0 x)))
            (let (y =a (field 0 scrutinee))
                (makeblock 0 1 (makeblock 0 y)))))
    (makeblock 0 0 0a))
\end{lstlisting}
\end{minipage}

The code on the right is in the Lambda intermediate representation of
the OCaml compiler. The Lambda representation of a program is shown by
calling the \texttt{ocamlc} compiler with \texttt{-drawlambda} flag.
(Some bindings in the generated code are unused or used exactly once;
they get substituted away in a simplification pass, whose result can
be shown by the \texttt{-dlambda} flag.)

The pattern matching compiler is a critical part of the compiler
in terms of correctness because bugs typically result in wrong code
production rather than compilation failures.
Such bugs also are hard to catch by testing because they arise in
corner cases of complex patterns which are typically not in the
compiler test suite or most user programs.
In the last five years there were (only) two bugs in the OCaml pattern
matching compiler; they resulted in silent wrong-code production,
and were found long after they were introduced.

We would like to keep evolving the pattern matching compiler, either by
using a new algorithm or by incremental refactorings.
We want to verify the changed compiler to ensure that no bugs were
introduced.

One could either verify the compiler implementation
(full verification) or check each input-output pair
(translation validation). We chose translation validation; it gives
a weaker result but is much easier to adopt in a production
compiler. The compiler is treated as a blackbox and proof only depends
on our equivalence algorithm between source and target programs.

\section{Our approach}

%% replace common TODO
Our algorithm translates both source and target programs into a common
representation, decision trees. Here are the decision tree for the
source and target example programs.

~

\begin{minipage}{0.4\linewidth}
\begin{verbatim}
       Switch(Root)
       /        \
     (= [])    (= ::)
     /             \
   Leaf         Switch(Root.1)
(0, None)       /         \
             (= [])      (= ::)
             /               \
          Leaf              Leaf
   [x = Root.0]         [y = Root.1.0]
   (1, Some x)          (2, Some y)
\end{verbatim}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
\begin{verbatim}
       Switch(Root)
       /        \
     (= int 0)  (!= int 0)
     /             \
   Leaf         Switch(Root.1)
(makeblock 0     /       \
  0 0a)         /         \
             (= int 0)    (!= int 0)
             /               \
          Leaf              Leaf
[x = Root.0]            [y = Root.1.0]
(makeblock 0            (makeblock 0
  1 (makeblock 0 x))      2 (makeblock 0 y))
\end{verbatim}
\end{minipage}

~

\texttt{Root.0} is an \emph{accessor}, it represents the
access path to a value that can be reached by deconstructing the
scrutinee (\texttt{li} in our example), in this case the first
subvalue of the scrutinee.

The nodes of condition trees branch on a condition on the accessor;
source conditions test the head constructor of the accessor, whereas
target conditions test the low-level representation of values in
Lambda code. For example, cons cells \texttt{x::xs} or tuples
\texttt{(x,y)} are heap blocks (with tag 0), while the empty list
\texttt{[]} is the immediate integer \texttt{0}.

In this simple example, the two decision trees perform exactly the
same checks in the same order, so the equivalence is obvious. However,
this may not be the case in general, as the compiler may reorder
checks or introduce redundant checks (to reduce code size).
%
To check the equivalence of a source and a target decision tree,
we proceed by case analysis.
%
If we have two leaves, we check that the target right-hand-side is the
compilation of the source right-hand-side, and that the captured
environments are identical over their free variables.
%
If we have a node $N$ and another tree $T$ we check equivalence for
each child of $N$. A child is a pair of a branch condition $\pi_i$ and a
subtree $C_i$. For every child $(\pi_i, C_i)$ we reduce $T$ by killing all
the branches that are incompatible with $\pi_i$ and check that the
reduced tree is equivalent to $C_i$.

\paragraph{Contributions} We have choosen a simple subset of the OCaml
language and implemented a prototype equivalence checker along with
a formal statement of correctness and proof sketches.

\section{From source programs to decision trees}
Our source language supports integers, lists, tuples and all algebraic
datatypes. Patterns support wildcards, constructors and literals,
or-patterns $(p_1 | p_2)$ and pattern variables.  We also support
\texttt{when} guards, which are interesting as they introduce the
evaluation of expressions during matching.  Decision trees have nodes
of the form:
\begin{lstlisting}
 type decision_tree =
  | Unreachable
  | Failure
  | Leaf of source_expr
  | Guard of source_expr * decision_tree * decision_tree
  | Switch of accessor * (constructor * decision_tree) list * decision_tree
\end{lstlisting}
In the \texttt{Switch} node we have one subtree for every head constructor
that appears in the pattern matching clauses and a fallback case for
other values. The branch condition $\pi_i$ expresses that the value at the
switch accessor starts with the given constructor.
\texttt{Failure} nodes express match failures for values that are not
matched by the source clauses.
\texttt{Unreachable} is used when we statically know that no value
can flow to that subtree.

We write $\sem{t_S}_S$ for the decision tree of the source program
$t_S$, computed by a matrix decomposition algorithm (each column
decomposition step gives a \texttt{Switch} node).
It satisfies the following correctness statement:
\[
\forall t_S, \forall v_S, \quad t_S(v_S) = \sem{t_S}_S(v_S)
\]
Running any source value $v_S$ against the source program gives the
same result as running it against the decision tree.

% TODO [Gabriel]: if there is space, it would make sense to mention
% the correctness condition for the decision tree of a matrix, which
% is less immediate than the one for whole programs and may be
% appreciated by the reviewers.

\section{From target programs to decision trees}
The target programs include the following Lambda constructs:
\texttt{let, if, switch, Match\_failure, catch, exit, field} and
various comparison operations, guards. The symbolic execution engine
traverses the target program and builds an environment that maps
variables to accessors. It branches at every control flow statement
and emits a \texttt{Switch} node. The branch condition $\pi_i$ is expressed as
an interval set of possible values at that point.
%
Guards result in branching on the boolean result.
%
In comparison with the source decision trees, \texttt{Unreachable}
nodes are never emitted.

We write $\sem{t_T}_T$ for the decision tree of the target program
$t_T$, satisfying the following correctness statement:
\[
\forall t_T, \forall v_T, \quad t_T(v_T) = \sem{t_T}_T(v_T)
\]

\section{Equivalence checking}
The equivalence checking algorithm takes as input a domain of
possible values \emph{S} and a pair of source and target decision trees and
in case the two trees are not equivalent it returns a counter example.
The algorithm respects the following correctness statement:

% TODO: we have to define what \covers mean for readers to understand the specifications
% (or we use a simplifying lie by hiding \covers in the statements).

\begin{align*}
 \Equiv S {C_S} {C_T} \emptyqueue = \Yes \;\land\; \covers {C_T} S
 & \implies
 \forall v_S \approx v_T \in S,\; C_S(v_S) = C_T(v_T)
\\
 \Equiv S {C_S} {C_T} \emptyqueue = \No {v_S} {v_T} \;\land\; \covers {C_T} S
 & \implies
 v_S \approx v_T \in S \;\land\; C_S(v_S) \neq C_T(v_T)
\end{align*}

% TODO: [Gabriel] I think that the explanation below could be more
% clearly presented as inference rules, I may try to make a proposal
% later.

The algorithm proceeds by case analysis.
If $S$ is empty the results is $\Yes$.
If the two decision trees are both terminal nodes the algorithm checks
for content equality.
If the source decision tree (left hand side) is a terminal while the
target decistion tree (right hand side) is not, the algorithm proceeds
by \emph{explosion} of the right hand side. Explosion means that every
child of the right hand side is tested for equality against the left
hand side.

% TODO: [Gabriel] in practice the $dom_S$ are constructors and the
% $dom_T$ are domains. Do we want to hide this fact, or be explicit
% about it? (Maybe we should introduce explicitly/clearly the idea of
% target domains at some point).

When the left hand side is not a terminal, the algorithm explodes the
left hand side while trimming every right hand side subtree. Trimming
a left hand side tree on an interval set $dom_S$ computed from the right hand
side tree constructor means mapping every branch condition $dom_T$ (interval set of
possible values) on the left to the intersection of $dom_T$ and $dom_S$ when
the accessors on both side are equal, and removing the branches that
result in an empty intersection. If the accessors are different,
\emph{$dom_T$} is left unchanged.

The equivalence checking algorithm deals with guards by storing a
queue. A guard blackbox is pushed to the queue whenever the algorithm
encounters a Guard node on the right, while it pops a blackbox from
the queue whenever a Guard node appears on the left hand side.
The algorithm stops with failure if the popped blackbox and the and
blackbox on the left hand Guard node are different, otherwise in
continues by exploding to two subtrees, one in which the guard
condition evaluates to true, the other when it evaluates to false.
Termination of the algorithm is successful only when the guards queue
is empty.

\begin{comment}

  ------------------------
  equiv \emptyset Cs Ct gs

  --------------------------
  equiv S Failure Failure []

  equiv_BB BBs BBt
  -------------------------------
  equiv S (Leaf BBs) (Leaf BBt) []

  Cs \in (Leaf BBs, Failure)
  (equiv S Cs Ci gs)^i
  equiv S Cs Cf gs
  -----------------------------------------
  equiv S Cs (Node(a, (Domi,Ci)^i, Cf)) gs

  equiv S Ci (trim Ct a=Ki) gs
  equiv S Cf (trim Ct (a\notin(K_i)^i) gs
  -------------------------------------
  equiv S (Node(a, (Ki,Ci)^i, Cf) Ct gs

  equiv S Ctrue Ct (gs++[condition])
  equiv S Cfalse Ct (gs++[condition])
  --------------------------------------------
  equiv S (Guard condition Ctrue Cfalse) Ct gs

  equiv S Cs Ctrue gs
  equiv S Cs Cfalse gs
  --------------------------------------------
  equiv S Cs (Guard condition Ctrue Cfalse) ([condition]++gs)
  
\end{comment}

% TODO integrate the rules below to the text of this section

Our equivalence-checking algorithm $\Equiv S {C_S} {C_T} G$ is
a exactly decision procedure for the provability of the judgment
$(\Equivrel S {C_S} {C_T} G)$, defined below.
\begin{mathpar}
  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{constraint trees}} \\
    C & \bnfeq & \Leaf t \\
    & \bnfor & \Failure \\
    & \bnfor & \Switch a {\Fam i {\pi_i, C_i}} \Cfb \\
    & \bnfor & \Guard t {C_0} {C_1} \\
  \end{array}

  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{boolean result}} \\
    b & \in & \{ 0, 1 \} \\[0.5em]
    & & \text{\emph{guard queues}} \\
    G & \bnfeq & (t_1 = b_1), \dots, (t_n = b_n) \\
  \end{array}

  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{input space}} \\
    S & \subseteq & \{ (v_S, v_T) \mid \vrel {v_S} {v_T} \} \\
  \end{array}
  \\
  \infer{ }
  {\Equivrel \emptyset {C_S} {C_T} G}

  \infer{ }
  {\Equivrel S \Failure \Failure \emptyqueue}

  \infer
  {\trel {t_S} {t_T}}
  {\Equivrel S {\Leaf {t_S}} {\Leaf {t_T}} \emptyqueue}

  \infer
  {\forall i,\;
    \Equivrel
      {(S \land a = K_i)}
      {C_i} {\trim {C_T} {a = K_i}} G
   \\
   \Equivrel
     {(S \land a \notin \Fam i {K_i})}
     \Cfb {\trim {C_T} {a \notin \Fam i {K_i}}} G
  }
  {\Equivrel S
    {\Switch a {\Fam i {K_i, C_i}} \Cfb} {C_T} G}

  % TODO explain somewhere why the judgment is not symmetric:
  % we avoid defining trimming on source trees, which would
  % require more expressive conditions than just constructors
  \infer
  {C_S \in {\Leaf t, \Failure}
   \\
   \forall i,\; \Equivrel {(S \land a \in D_i)} {C_S} {C_i} G
   \\
   \Equivrel {(S \land a \notin \Fam i {D_i})} {C_S} \Cfb G}
  {\Equivrel S
    {C_S} {\Switch a {\Fam i {D_i} {C_i}} \Cfb} G}

  \infer
  {\Equivrel S {C_0} {C_T} {G, (t_S = 0)}
   \\
   \Equivrel S {C_1} {C_T} {G, (t_S = 1)}}
  {\Equivrel S
    {\Guard {t_S} {C_0} {C_1}} {C_T} G}

  \infer
  {\trel {t_S} {t_T}
   \\
   \Equivrel S {C_S} {C_b} G}
  {\Equivrel S
    {C_S} {\Guard {t_T} {C_0} {C_1}} {(t_S = b), G}}
\end{mathpar}

\end{document}

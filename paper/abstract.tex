\documentclass[12pt]{article}
\usepackage{a4}
\usepackage[margin=2cm]{geometry}

\usepackage[utf8]{inputenc}

\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage{hyperref}
\usepackage[dvipsnames]{xcolor}
\hypersetup{breaklinks=true,colorlinks=true,citecolor=OliveGreen,urlcolor=Plum}

\usepackage{comment}
\usepackage{mathpartir}
\usepackage{stmaryrd} % llbracket, rrbracket
\usepackage{listings}
\lstset{
  mathescape=true,
  language=[Objective]{Caml},
  basicstyle=\ttfamily,
  extendedchars=true,
  showstringspaces=false,
  aboveskip=\smallskipamount,
  % belowskip=\smallskipamount,
  columns=fullflexible,
  moredelim=**[is][\color{blue}]{/*}{*/},
  moredelim=**[is][\color{green!60!black}]{/!}{!/},
  moredelim=**[is][\color{orange}]{/(}{)/},
  moredelim=[is][\color{red}]{/[}{]/},
  xleftmargin=1em,
}
\lstset{aboveskip=0.4ex,belowskip=0.4ex}

\usepackage{notations}

\title{Translation validation of a pattern-matching compiler}
\author{Francesco Mecca, Gabriel Scherer}

\begin{document}
\maketitle

\begin{abstract}
We propose an algorithm for the translation validation of a pattern
matching compiler for a small subset of the OCaml pattern
matching features. Given a source program and its compiled version the
algorithm checks wheter the two are equivalent or produce a counter
example in case of a mismatch.

Our equivalence algorithm works with decision trees. Source patterns are
converted into a decision tree using matrix decomposition.
Target programs, described in a subset of the Lambda intermediate
representation of the OCaml compiler, are turned into decision trees
by applying symbolic execution.
\end{abstract}
\section{Translation validation}
A pattern matching compiler turns a series of pattern matching clauses
into simple control flow structures such as \texttt{if, switch}, for example:

\hspace{-3em}
\begin{minipage}{0.4\linewidth}
\begin{lstlisting}
  match li with
  | [] -> (0, None)
  | x::[] -> (1, Some x)
  | _::y::_ -> (2, Some y)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.6\linewidth}
\begin{lstlisting}
(if li
    (let (tl =a (field 1 li))
        (if tl
            (let (y =a (field 0 tl))
                (makeblock 0 2 (makeblock 0 y)))
            (let (x =a (field 0 li))
                (makeblock 0 1 (makeblock 0 x)))))
    (makeblock 0 0 0a))
\end{lstlisting}
\end{minipage}

The code on the right is in the Lambda intermediate representation of
the OCaml compiler. The Lambda representation of a program is shown by
calling the \texttt{ocamlc} compiler with \texttt{-drawlambda} flag.

The pattern matching compiler is a critical part of the compiler
in terms of correctness because bugs typically result in wrong code
production rather than compilation failures.
Such bugs also are hard to catch by testing because they arise in
corner cases of complex patterns which are typically not in the
compiler test suite or most user programs.
In the last five years there were (only) two known bugs in the OCaml pattern
matching compiler; they resulted in silent wrong-code production,
and were found long after they were introduced.

We would like to keep evolving the pattern matching compiler, either by
using a new algorithm or by incremental refactorings.
We want to verify the changed compiler to ensure that no bugs were
introduced.

One could either verify the compiler implementation
(full verification) or check each input-output pair
(translation validation). We chose translation validation; it gives
a weaker result but is much easier to adopt in a production
compiler. The compiler is treated as a blackbox and proof only depends
on our equivalence algorithm between source and target programs.

\section{Decision Trees}

Our algorithm translates both source and target
programs into a common representation, \emph{decision trees}.
Here are the decision tree for the source and target example programs.

~

\hspace{-2em}
\begin{minipage}{0.5\linewidth}
\begin{verbatim}
       Switch(Root)
       /        \
     (= [])    (= ::)
     /             \
   Leaf         Switch(Root.1)
(0, None)       /         \
             (= [])      (= ::)
             /               \
          Leaf              Leaf
   [x = Root.0]         [y = Root.1.0]
   (1, Some x)          (2, Some y)
\end{verbatim}
\end{minipage}
\hfill
\begin{minipage}{0.5\linewidth}
\begin{verbatim}
       Switch(Root)
       /        \
     (= int 0)  (!= int 0)
     /             \
   Leaf         Switch(Root.1)
(makeblock 0     /       \
  0 0a)         /         \
             (= int 0)    (!= int 0)
             /               \
          Leaf              Leaf
[x = Root.0]            [y = Root.1.0]
(makeblock 0            (makeblock 0
  1 (makeblock 0 x))      2 (makeblock 0 y))
\end{verbatim}
\end{minipage}

~

\texttt{Root.0} is an \emph{accessor}, it represents the
access path to a value that can be reached by deconstructing the
scrutinee (\texttt{li} in our example), in this case the first
subvalue of the scrutinee.

Source conditions test the head constructor of the accessor, whereas
target conditions test the low-level representation of values in
Lambda code. For example, cons cells \texttt{x::xs} or tuples
\texttt{(x,y)} are heap blocks (with tag 0), while the empty list
\texttt{[]} is the immediate integer \texttt{0}.

In this simple example, the two decision trees perform exactly the
same checks in the same order, so the equivalence is obvious. However,
this may not be the case in general, as the compiler may reorder
checks, simplify away redundant checks or sometimes add them to reduce
code size.

\paragraph{Computing a source decision tree}

To compute the decision tree of a source program we use the standard
approach of \emph{matrix decomposition}. A pattern matrix is an
intermediate datastructure that represents matching on several values
in parallel. Each column of the matrix matches on a sub-value of the
original scrutinee, denoted by an accessor $a_i$. For example, the
matrix on the left corresponds roughly to the tuple pattern on the
right:

\begin{minipage}{0.4\linewidth}
\begin{mathpar}
\begin{array}{lllll}
\phantom{(}a_1 & a_2 & a_3 & & \\
(p_{1,1} & p_{1,2} & p_{1,3} & \to & e_1) \\
(p_{2,1} & p_{2,2} & p_{2,3} & \to & e_2) \\
\end{array}
\end{mathpar}
\end{minipage}
\hfill
\begin{minipage}{0.6\linewidth}
\begin{lstlisting}
match ($a_1$, $a_2$, $a_3$) with
| ($p_{1,1}$, $p_{1,2}$, $p_{1,3}$) -> $e_1$
| ($p_{2,1}$, $p_{2,2}$, $p_{2,3}$) -> $e_2$
\end{lstlisting}
\end{minipage}

~

The central operation is to \emph{decompose} a given matrix by looking
at the variant constructors that occur in the first column, $(p_1$,
$p_2)$ in our example). For each constructor we compute a smaller
\emph{submatrix} containing the rows that match this constructor.


For example, the decomposition of the matrix on the left gives the two
submatrices on the right, one for the \texttt{Some} constructor and
one for \texttt{None}.

\begin{mathpar}
\begin{array}{lllll}
\phantom{(}a_1 & a_2 & a_3 & & \\
(\mathtt{Some}(q) & p_{1,2} & p_{1,3} & \to & e_1) \\
(\any & p_{2,2} & p_{2,3} & \to & e_2) \\
(\mathtt{None} & p_{3,2} & p_{3,3} & \to & e_3) \\
\end{array}

\begin{array}{l}
{\begin{array}{lllll}
\phantom{(}{a_1}.1 & a_2 & a_3 & & \\
(q & p_{1,2} & p_{1,3} & \to & e_1) \\
(\any & p_{2,2} & p_{2,3} & \to & e_2) \\
\end{array}}
\\[2em]
{\begin{array}{llll}
\phantom{(}a_2 & a_3 & & \\
(p_{2,2} & p_{2,3} & \to & e_2) \\
(p_{3,2} & p_{3,3} & \to & e_3) \\
\end{array}}
\end{array}
\end{mathpar}

We build a decomposition tree by repeating this decomposition step. At
each step we emit a \texttt{Switch} node on the accessor of the first
column. We have one sub-tree per submatrix, and the branch condition
checks for the submatrix constructor.

We emit a leaf node when repeated decomposition reaches a matrix with
empty rows (no columns).

\paragraph{Computing a target decision tree}

The target programs include the following Lambda constructs:
\texttt{let, if, switch, Match\_failure, catch, exit, field} and
various comparison operations, guards. A simple symbolic execution
engine traverses the target program, keeping an environment that maps
variables to accessors. It branches at every control flow statement
and emits a \texttt{Switch} node. The branch condition $\pi_i$ is
expressed as an interval set of possible values at that point.

For example, consider the Lambda fragment
%
\lstinline{if (= x 0) e1 e2)}.
%
We build a \lstinline{Switch} node with two children, one for
\lstinline{e1} and one for \lstinline{e2}. We get the accessor
corresponding to \lstinline{x} in the symbolic environment, and the
branch conditions of the two subtrees would correspond respectively to
\lstinline{= 0} (the domain $[0]$) and \lstinline{!= 0} (the domain
$[\mathtt{min\_int}; -1] \cup [1; \mathtt{max\_int}]$).

\section{Checking equivalence}

We now give a simplified sketch of our equivalence
algorithm. A complete overview is given in appendices.

To check the equivalence of a source and a target decision tree,
we proceed recursively by case analysis.
%
If we have two leaves, we check that the target right-hand-side is the
compilation of the source right-hand-side, and that the captured
environments are identical over their free variables.
%
If we have a node $N$ and another tree $T$ we check equivalence for
each child of $N$. A child is a pair of a branch condition $\pi_i$ and a
subtree $C_i$. For every child $(\pi_i, C_i)$ we reduce $T$ by killing all
the branches that are incompatible with $\pi_i$ and check that the
reduced tree is equivalent to $C_i$.

\paragraph{Contributions} We have chosen a simple subset of the OCaml
language and implemented a prototype equivalence checker along with
a formal statement of correctness and proof sketches.

Our source language supports integers, lists, tuples and algebraic
datatypes. Patterns support wildcards, constructors and literals,
or-patterns $(p_1 | p_2)$ and pattern variables.  We also support
\texttt{when} guards, which are interesting as they introduce the
evaluation of expressions during matching.

Our current implementation prototype can be found at:
\begin{center}
  \url{https://github.com/FraMecca/inria-internship/}.
\end{center}

\newpage
\appendix

\section{A formal setting}

We will use, but not define by lack of space, the notion of source and
target \emph{programs} $t_S$ and $t_T$, and \emph{expressions} $e_S$
and $e_T$. A source program $t_S$ is a list of pattern-matching
clauses (with an optional \texttt{when}-guard) of the form
\lstinline{| $p$ (when $e_S$)? -> $e_S$}, and a target program $t_T$
is a series of control-flow conditionals (\texttt{if, switch,
  Match\_failure, catch, exit}), value access (\texttt{field}),
variable bindings (\texttt{let}) and comparison operators in Lambda
code, with arbitrary Lambda-code expressions $e_T$ at the leaves.

We assume given an equivalence relation $\erel {e_S} {e_T}$ on leaf
expressions. In our translation-validation setting, it suffices to
relate each source expression to its compiled form -- the compiler
gives/computes this relation. We have to lift this relation on leaves
into an equivalence procedure for (pattern-matching) programs.

\begin{mathpar}
  \erel {e_S} {e_T} \; (\text{\emph{assumed}})

  t_S(v_S),\ t_T(v_T),\ \vrel {v_S} {v_T} \; (\text{\emph{omitted}})

  \resrel {r_S} {r_T}, \runrel {R_S} {R_T} \; (\text{\emph{simple}})
\\
  \begin{array}{l@{~}r@{~}r@{~}l}
    \text{\emph{environment}} & \sigma(v)
    & \bnfeq & [x_1 \mapsto v_1, \dots, v_n \mapsto v_n] \\
    \text{\emph{closed term}} & \cle(v)
    & \bnfeq & (\sigma(v), e) \\
  \end{array}
\quad
  \begin{array}{l@{~}r@{~}r@{~}l}
    \text{\emph{matching result}} & r(v)
    & \bnfeq & \NoMatch \bnfor \Match {\cle(v)} \\
    \text{\emph{matching run}} & R(v)
    & \bnfeq & (\cle(v)_1, \dots, \cle(v)_n), r(v) \\
  \end{array}
\\
  \infer
  {\forall x,\ \vrel {\sigma_S(x)} {\sigma_T(x)}}
  {\envrel {\sigma_S} {\sigma_T}}

  \infer
  {\envrel {\sigma_S} {\sigma_T} \\ \erel {e_S} {e_T}}
  {\clerel {(\sigma_S, e_S)} {(\sigma_T, e_T)}}

  \infer
  {\forall {\vrel {v_S} {v_T}},\quad \runrel {t_S(v_S)} {t_T(v_T)}}
  {\progrel t_S t_T}
\end{mathpar}

We use $v_S$ and $v_T$ for source and target values, and define
a relation $\vrel {v_S} {v_T}$ to relate a source to a target value;
this relation (omitted by lack of space) captures our knowledge of the
OCaml value representation, for example it relates the empty list
constructor \texttt{[]} to $\Int 0$. We can then define \emph{closed}
expressions $\cle$, pairing a (source or target) expression with the
environment $\sigma$ captured by a program, and what it means to
``run'' a value against a program or a decision, written $t(v)$ and
$C(v)$, which returns a trace $(\cle_1, \dots, \cle_n)$ of the
executed guards and a \emph{matching result} $r$.

Once formulated in this way, our equivalence algorithm must check the
natural notion of input-output equivalence for matching programs,
captured by the relation $\progrel {t_S} {t_T}$.

\section{Decision trees}

The parametrized grammar $C(\pi, e)$ describes the common structure of
source and decision trees. We use $\pi$ for the \emph{conditions} on
each branch, and $a$ for our \emph{accessors}, which give a symbolic
description of a sub-value of the scrutinee. Source conditions $\pi_S$
are just datatype constructors; target conditions $\pi_T$ are
arbitrary sets of possible immediate-integer or block-tag values.

%TODO [Gabriel] rename C (Constraint trees) into D (Decision trees).
\begin{mathpar}
  \begin{array}{l@{~}r@{~}r@{~}l}
    \text{\emph{decision trees}} & C(\pi, e)
    & \bnfeq & \Leaf {\cle(a)} \\
    & & \bnfor & \Failure \\
    & & \bnfor & \Switch a {\Fam {i \in I} {\pi_i, C_i}} \Cfb \\
    & & \bnfor & \Guard {\cle(a)} {C_0} {C_1} \\
    \text{\emph{accessors}} & a
    & \bnfeq & \Root \;\bnfor\; a.n \quad (n \in \mathbb{N}) \\
  \end{array}

  \begin{array}{l}
  \pi_S : \text{datatype constructors}
  \\
  \pi_T \subseteq        \{ \Int n \mid n \in \mathbb{Z} \}
                  \uplus \{ \Tag n \mid n \in \mathbb{N} \}
  \\[1em]
  C_S(v_S), C_T(v_T) \quad \text{\emph{omitted}}
  \end{array}
\end{mathpar}

The tree $\Leaf \cle$ returns a leaf expression $e$ in a captured
environment $\sigma$ mapping variables to accessors.
%
$\Failure$ expresses match failure, when no clause matches the input
value.
%
$\Switch a {\Fam {i \in I} {\pi_i, C_i}} \Cfb$ has one subtree $C_i$
for every head constructor that appears in the pattern matching
clauses, and a fallback case for the constructors.
%
$\Guard \cle {C_0} {C_1}$ represents a \texttt{when}-guard on a closed
expression $\cle$, expected to be of boolean type, with sub-trees
$C_0$ for the \texttt{true} case and $C_1$ for the \texttt{false}
case.

\section{From source programs to decision trees: matrix decomposition}

We write $\sem{t_S}_S$ for the decision tree of the source program
$t_S$, computed by a matrix decomposition algorithm.
It satisfies the following correctness statement:
\[
\forall t_S, \forall v_S, \quad \runrel {t_S(v_S)} {\sem{t_S}_S(v_S)}
\]
Running any source value $v_S$ against the source program gives the
same result as running it against the decision tree.

% TODO [Gabriel]: write the correctness statement for the matrix version as well.

\section{From target programs to decision trees: symbolic execution}

We write $\sem{t_T}_T$ for the decision tree of the target program
$t_T$, satisfying a correctness statement similar to the source one:
\[
\forall t_T, \forall v_T, \quad \runrel {t_T(v_T)} {\sem{t_T}_T(v_T)}
\]

\section{Equivalence checking}

During equivalence checking we traverse the two trees, recursively checking equivalence of pairs of subtrees.
When we traverse a branch condition, we learn a condition
on an accessor that restricts the set of possible input values that can flow in the corresponding subtree.
We represent this in our algorithm as an \emph{input domain} $S$ of possible values (a mapping from accessors to target domains).

The equivalence checking algorithm $\SimpleEquiv S {C_S} {C_T}$ takes an input domain \emph{S} and a pair of source and target decision trees. In case the two trees are not equivalent, it returns a counter example.

It is defined exactly as a decision procedure for the provability of the judgment
$(\Equivrel S {C_S} {C_T} \emptyqueue)$, defined below in the general
form $(\Equivrel S {C_S} {C_T} G)$ where $G$ is a \emph{guard queue},
indicating an imbalance between the guards observed in the source tree
and in the target tree. (For clarity of exposition, the inference rules do not explain how we build the counter-example.)
\begin{mathpar}
  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{input space}} \\
    S & \subseteq & \{ (v_S, v_T) \mid \vrel {v_S} {v_T} \} \\
  \end{array}

  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{boolean result}} \\
    b & \in & \{ 0, 1 \} \\
  \end{array}

  \begin{array}{l@{~}r@{~}l}
    & & \text{\emph{guard queues}} \\
    G & \bnfeq & (t_1 = b_1), \dots, (t_n = b_n) \\
  \end{array}
  \\
  \infer[empty]{ }
  {\Equivrel \emptyset {C_S} {C_T} G}

  \infer{ }
  {\Equivrel S \Failure \Failure \emptyqueue}

  \infer
  {\erel {t_S} {t_T}}
  {\Equivrel S {\Leaf {t_S}} {\Leaf {t_T}} \emptyqueue}

  \infer[explode-left]
  {\forall i,\;
    \Equivrel
      {(S \land a = K_i)}
      {C_i} {\trim {C_T} {a = K_i}} G
   \\
   \Equivrel
     {(S \land a \notin \Fam i {K_i})}
     \Cfb {\trim {C_T} {a \notin \Fam i {K_i}}} G
  }
  {\Equivrel S
    {\Switch a {\Fam i {K_i, C_i}} \Cfb} {C_T} G}

  % TODO explain somewhere why the judgment is not symmetric:
  % we avoid defining trimming on source trees, which would
  % require more expressive conditions than just constructors
  \infer[explode-right]
  {C_S \in {\Leaf t, \Failure}
   \\
   \forall i,\; \Equivrel {(S \land a \in D_i)} {C_S} {C_i} G
   \\
   \Equivrel {(S \land a \notin \Fam i {D_i})} {C_S} \Cfb G}
  {\Equivrel S
    {C_S} {\Switch a {\Fam i {D_i} {C_i}} \Cfb} G}

  \infer
  {\Equivrel S {C_0} {C_T} {G, (e_S = 0)}
   \\
   \Equivrel S {C_1} {C_T} {G, (e_S = 1)}}
  {\Equivrel S
    {\Guard {e_S} {C_0} {C_1}} {C_T} G}

  \infer
  {\erel {e_S} {e_T}
   \\
   \Equivrel S {C_S} {C_b} G}
  {\Equivrel S
    {C_S} {\Guard {e_T} {C_0} {C_1}} {(e_S = b), G}}
\end{mathpar}

% TODO[Gabriel]: fix \Rule macro
The \Rule{empty} rule states that two subtrees are equivalent when the input domain is empty. This is used when the two subtrees constrain the input in incompatible ways.

The explosion rules are used when a `Switch` node occurs on either side. Each child of this switch is tested for equality against the other tree. The branch condition of the child is used to refine the input domain.

As an optimization, in the \Rule{explode-left} rule we \emph{trim} the target tree, by simplifying the tree in depth with the source condition. Trimming
a target tree on a domain $dom_S$ computed from a source constructor means mapping every branch condition $dom_T$ of every node of the target tree to the intersection of $dom_T$ and $dom_S$ when the accessors on both sides are equal, and removing the branches that result in an empty intersection. If the accessors are different, \emph{$dom_T$} is left unchanged.
Trimming avoids redundant work, because each target subtree removed (in one step) by trimming would have been traversed during the equivalence computation of each source subtree, potentially many times.

We have only defined trimming of a target tree, not of a source tree: the branch condition on the source tree are just constructors, so they are less expressive than target domains and it is hard to define an intersection between the two. We restrict the \Rule{explode-right} rule to only work on terminal source trees, so that no duplicate work occurs.

There is no guarantee that the guards will appear at the same level on both sides. We store a \emph{guard queue} $G$ that
tracks the guard conditions that we have traversed in the source tree, but not yet in the target tree, with the boolean result of each condition.
%
Termination of the algorithm is successful only when the guards queue is empty. This ensures that both sides executed the same guards, in the same order -- guard conditions may perform side-effects, so their order can be observed.

The algorithm respects the following correctness statement:
% TODO: we have to define what \covers mean for readers to understand the specifications
% (or we use a simplifying lie by hiding \covers in the statements).
\begin{align*}
 \SimpleEquiv S {C_S} {C_T} = \Yes \;\land\; \covers {C_T} S
 & \implies
 \forall {\vrel {v_S} {v_T}} \in S,\; \runrel {C_S(v_S)} {C_T(v_T)}
\\
 \SimpleEquiv S {C_S} {C_T} = \No {v_S} {v_T} \;\land\; \covers {C_T} S
 & \implies
 \vrel {v_S} {v_T} \in S \;\land\; {\nparamrel{run} {C_S(v_S)} {C_T(v_T)}}
\end{align*}

The technical condition $\covers {C_T} S$ means that for each node of the (target) tree, the union of the branch conditions include the whole input domain. It obviously holds for the decision trees generated from the source and target program (they cover the whole input domain). It is preserved by our inference rules, because trimming preserves coverage.

\end{document}

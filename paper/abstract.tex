\documentclass[12pt]{article}
\usepackage{a4}
\usepackage[margin=.5cm,bottom=1.5cm]{geometry}

\usepackage[utf8]{inputenc}

\usepackage{amsmath}

\usepackage{mathpartir}
\usepackage{stmaryrd}
\newcommand{\sem}[1]{{\llbracket{#1}\rrbracket}}
\usepackage{listings}
\lstset{
  mathescape=true,
  language=[Objective]{Caml},
  basicstyle=\ttfamily,
  extendedchars=true,
  showstringspaces=false,
  aboveskip=\smallskipamount,
  % belowskip=\smallskipamount,
  columns=fullflexible,
  moredelim=**[is][\color{blue}]{/*}{*/},
  moredelim=**[is][\color{green!60!black}]{/!}{!/},
  moredelim=**[is][\color{orange}]{/(}{)/},
  moredelim=[is][\color{red}]{/[}{]/},
  xleftmargin=1em,
}
\lstset{aboveskip=0.4ex,belowskip=0.4ex}

\newcommand{\match}[2]{\mathtt{match}(#1,#2)}

\newcommand{\var}[1]{\mathtt{#1}}
\newcommand{\pK}{\mathtt{K}}
\newcommand{\any}{\mathtt{\_}}

\title{Translation validation of a pattern-matching compiler}
\author{Francesco Mecca, Gabriel Scherer}

\begin{document}
\maketitle

\begin{abstract}
We propose an algorithm for the translation validation of a pattern
matching compiler for a small subset of the OCaml pattern
matching features. Given a source program and its compiled version the
algorithm checks wheter the two are equivalent or produce a counter
example in case of a mismatch.

Our equivalence algorithm works with decision trees. Source patterns are
converted into a decision tree using matrix decomposition.
Target programs, described in a subset of the Lambda intermediate
representation of the OCaml compiler, are turned into decision trees
by applying symbolic execution.
\end{abstract}
\section{Translation validation}
A pattern matching compiler turns a series of pattern matching clauses
into simple control flow structures such as \texttt{if, switch}, for example:

\begin{minipage}{0.3\linewidth}
\begin{lstlisting}
  match li with
  | [] -> (0, None)
  | x::[] -> (1, Some x)
  | _::y::_ -> (2, Some y)
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.7\linewidth}
\begin{lstlisting}
(if li
    (let (tl =a (field 1 li))
        (if tl
            (let (tltl =a (field 1 tl)
                  x =a (field 0 tl))
                (makeblock 0 2 (makeblock 0 x)))
            (let (y =a (field 0 scrutinee))
                (makeblock 0 1 (makeblock 0 y)))))
    (makeblock 0 0 0a))
\end{lstlisting}
\end{minipage}

The code in the right is in the Lambda intermediate representation of
the OCaml compiler. The Lambda representation of a program is shown by
calling the \texttt{ocamlc} compiler with \texttt{-drawlambda} flag.
(Some bindings in the generated code are unused or used exactly once;
they get substituted away in a simplification pass, whose result can
be shown by the \texttt{-dlambda} flag.)

The pattern matching compiler is a critical part of the compiler
in terms of correctness because any bug would result in wrong code
production rather than compilation failures.
Such bugs also are hard to catch by testing because they arise in
corner cases of complex patterns which are typically not in the
compiler test suite.
In the last five years there were (only) two bugs in the OCaml pattern
matching compiler; they were found long after they were introduced.

We have considered evolving the pattern matching compiler, either by
using a new algorithm or by incremental refactorings.
We want to verify the changed compiler to ensure that no bugs were
introduced.

One could either verify the compiler implementation or check each
input output pair. We chose the latter technique, translation
validation; it which gives a weaker result but is easier to adopt in
the case of a production compiler. The compiler is treated as a
blackbox and proof only depends on our equivalence algorithm between
source and target programs.

\section{Our approach}
%% replace common TODO
Our algorithm translates both source and target programs into a common
representation, decision trees. Here is the decision tree for the
source example program.
\begin{verbatim}
       Node(Root)
       /        \
     (= [])    (= ::)
     /             \
   Leaf         Node(Root.1)
(0, None)       /         \
             (= [])      (= ::)
             /               \
          Leaf              Leaf
   (1, Some(Root.0))   (2, Some(Root.1.0))
\end{verbatim}
\texttt{(Root.0)} is called an \emph{accessor}, that represents the
access path to a value that can be reached by deconstructing the
scrutinee. In this example \texttt{Root.0} is the first subvalue of the scrutinee.

Target decision trees have a similar shape but the tests on the
branches are related to the low level representation of values in
Lambda code. For example, cons cells \texttt{x::xs} are blocks with
tag 0.

To check the equivalence of a source and a target decision tree,
we proceed by case analysis.
If we have two leaves, we check that the two right-hand-sides are
equivalent.
If we have a node $N$ and another tree $T$ we check equivalence for
each child of $N$, which is a pair of a branch condition $\pi_i$ and a
subtree $C_i$. For every child $(\pi_i, C_i)$ we reduce $T$ by killing all
the branches that are incompatible with $\pi_i$ and check that the
reduced tree is equivalent to $C_i$.

We have choosen a simple subset of the OCaml language and implemented a
prototype equivalence checker along with a formal statement of
correctness and proof sketches.

\section{From source programs to decision trees}
Our source language supports integers, lists, tuples and all algebraic
datatypes. Patterns support wildcards, constructors and literals, or
patterns $(p_1|p_2)$ and pattern variables.
We also support \texttt{when} guards.
Decision trees have nodes of the form:
\begin{lstlisting}
 type decision_tree =
  | Unreachable
  | Failure
  | Leaf of source_expr
  | Guard of source_expr * decision_tree * decision_tree
  | Switch of accessor * (constructor * decision_tree) list * decision_tree
\end{lstlisting}
In the \texttt{Switch} node we have one subtree for every head constructor
that appears in the pattern matching clauses and a fallback case for
other values. The branch condition $\pi_i$ expresses that the value at the
switch accessor starts with the given constructor.
\texttt{Failure} nodes express match failures for values that are not
matched by the source clauses.
\texttt{Unreachable} is used when we statically know that no value
can flow to that subtree.

We write $\sem{t_S}_S$ for the decision tree of the source program
$t_S$, computed by a matrix decomposition algorithm (each column
decomposition step gives a \texttt{Switch} node).
It satisfies the following correctness statement:
\[
\forall t_S, \forall v_S, \quad t_S(v_S) = \sem{t_S}_S(v_S)
\]
Running any source values $v_S$ against the source program gives the
same result as running it against the decision tree.

\section{From target programs to decision trees}
The target programs include the following Lambda constructs:
\texttt{let, if, switch, Match\_failure, catch, exit, field} and
various comparation operations, guards. The symbolic execution engine
traverses the target program and builds an environment that maps
variables to accessors. It branches at every control flow statement
and emits a Switch node. The branch condition $\pi_i$ is expressed as
an interval set of possible values at that point.
Guards result in branching. In comparison with the source decision
trees, \texttt{Unreachable} nodes are never emitted.

We write $\sem{t_T}_T$ for the decision tree of the target program
$t_T$, satisfying the following correctness statement:
\[
\forall t_T, \forall v_T, \quad t_T(v_T) = \sem{t_T}_T(v_T)
\]

\section{Equivalence checking}
The equivalence checking algorithm takes as input a domain of
possible values \emph{S} and a pair of source and target decision trees and
in case the two trees are not equivalent it returns a counter example.
The algorithm respects the following correctness statement:

\[
 equiv(S, C_S, C_T) = Yes \land C_T cover S \to \forall v_S \approx
v_T \in S \land C_S(v_S) = C_T(v_T)
\]
\[
equiv(S, C_S, C_T) = No(v_S,v_T) \land C_T cover S \to \forall v_S \approx
v_T \in S \land C_S(v_S) \neq C_T(v_T)
\]
The algorithm proceeds by case analysis.
If \emph{S} is empty the results is Yes.
If the two decision trees are both terminal nodes the algorithm checks
for content equality.
If the source decision tree (left hand side) is a terminal while the
target decistion tree (right hand side) isn't, the algorithm proceeds
by \emph{explosion} of the right hand side. Explosion means that every
child of the right hand side is tested for equality against the left
hand side.
When the left hand side is not a terminal, the algorithm explodes the
left hand side while trimming every right hand side subtree. Trimming
a left hand side tree on an interval set \emph{$dom_S$} computed from the right hand
side tree constructor means mapping every branch condition \emph{$dom_T$} (interval set of
possible values) on the left to the intersection of \emph{$dom_T$} and \emph{$dom_S$} when
the accessors on both side are equal, and removing the branches that
result in an empty intersection. If the accessors are different,
\emph{$dom_T$} is left unchanged.

The equivalence checking algorithm deals with guards by storing a
queue. A guard blackbox is pushed to the queue whenever the algorithm
encounters a Guard node on the right, while it pops a blackbox from
the queue whenever a Guard node appears on the left hand side.
The algorithm stops with failure if the popped blackbox and the and
blackbox on the left hand Guard node are different, otherwise in
continues by exploding to two subtrees, one in which the guard
condition evaluates to true, the other when it evaluates to false.
Termination of the algorithm is successful only when the guards queue
is empty.



\end{document}

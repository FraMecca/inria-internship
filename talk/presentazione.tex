\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usetheme{Boadilla}
\title{Translation validation of a pattern-matching compiler}
\subtitle{}
\author{Francesco Mecca (University of Turin), Gabriel Scherer (INRIA)}
\date{\today}

\usepackage{mybeamer}

\usepackage{listings}
\lstset{
  mathescape=true,
  language=[Objective]{Caml},
  basicstyle=\ttfamily,
  commentstyle=\ttfamily, % hack to avoid issues with "let (*match*/94" ...
  extendedchars=true,
  showstringspaces=false,
  aboveskip=\smallskipamount,
  % belowskip=\smallskipamount,
  columns=fullflexible, % avoiding monospace spaces reduces code width
  moredelim=**[is][\color{blue}]{/*}{*/},
  moredelim=**[is][\color{green!60!black}]{/!}{!/},
  moredelim=**[is][\color{orange}]{/(}{)/},
  moredelim=[is][\color{red}]{/[}{]/},
  xleftmargin=1em,
}
\lstset{aboveskip=0.4ex,belowskip=0.4ex}


\begin{document}
%% TODO: say that correctness statements are in abstract

%%% First page
\begin{frame}
  \titlepage
\end{frame}

\section{Motivation}
\subsection{Translation Validation}

\begin{frame}
  \frametitle{What is Translation Validation}
  Translation validation is a  weaker technique of formal correctness. \\
  At every run of the compiler the input code (source) and the generated code (target) are fed to a
  validator. \\
  The validator is independent of the compiler and establish
  \emph{a posteriori} if the two inputs are observationally
  equivalent.
  %% Is it really observational equivalence or is it stronger?
\end{frame}
\begin{frame}
  \frametitle{Why Translation Validation}
  The compiler is treated as a blackbox. \\
  If the validator is formally proved, it gives the same level of
  assurance as the full formal verification of the compiler. \\
  %% Better way to say "full formal verification"
  %% Maybe specify what "assurance" means or find another way to
  %% express that
  In case of failure, the validator points out the mismatches between
  the two programs. \\
  Less effort than full verification.
\end{frame}

\subsection{Our objective}
\begin{frame}
  \frametitle{Our objective}
We propose an algorithm for the translation validation of a pattern
matching compiler for a small subset of the OCaml pattern
matching features. \\
We avoid the problem of undecidability by restricing the source
language to a subset of the OCaml language.\\
However we will see that work still supports the full output of the
OCaml compiler.
\end{frame}

\begin{frame}
  \frametitle{Related Work}
  %% TODO
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: source and target programs}
The target program is exactly the \emph{-drawlambda} output of the compiler.

\begin{small}
\hspace{-1em}
\begin{minipage}{0.36\linewidth}
  \begin{lstlisting}
type 'a option =
  | None
  | Some of 'a
let mm test ret = function
  | Some x when $\bgalertcyan<2>{\text{test x}}$ -> $\bgalert<2>{\text{ret x}}$
  | Some 42 -> $\bgalert<2>{\text{ret 42}}$
  | _ -> $\bgalert<2>{\text{ret 0}}$
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.64\linewidth}
\begin{lstlisting}
(mm/80 =
   (function test/82 ret/83 param/85
     (catch
       (if param/85
         (let (x/84 =a (field 0 param/85))
           (if $\bgalertcyan<2>{\text{(apply test/82 x/84)}}$
             $\bgalert<2>{\text{(apply ret/83 x/84)}}$
             (if (!= x/84 42)
               (exit 1)
               $\bgalert<2>{\text{(apply ret/83 42))}}$))
         (exit 1))
      with (1)
        $\bgalert<2>{\text{(apply ret/83 0)}}$)))
\end{lstlisting}
\end{minipage}
\end{small}
\pause
\end{frame}

\begin{frame}[fragile]
  \frametitle{Target program}
\end{frame}

%%% table of contents
\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

\end{document}

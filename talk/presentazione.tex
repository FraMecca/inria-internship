\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usetheme{Boadilla}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{\hfill\insertframenumber\hfill\vspace{3mm}}

\title{Translation validation of a pattern-matching compiler}
\subtitle{}
\author{Francesco Mecca (University of Turin), Gabriel Scherer (INRIA)}
\date{\today}

\usepackage{mybeamer}

\usepackage{tikz} % commutative diagrams
\usetikzlibrary{cd}
\usetikzlibrary{decorations.pathmorphing}

\usepackage{listings}
\lstset{
  mathescape=true,
  language=[Objective]{Caml},
  basicstyle=\ttfamily,
  commentstyle=\ttfamily, % hack to avoid issues with "let (*match*/94" ...
  extendedchars=true,
  showstringspaces=false,
  aboveskip=\smallskipamount,
  % belowskip=\smallskipamount,
  columns=fullflexible, % avoiding monospace spaces reduces code width
  moredelim=**[is][\color{blue}]{/*}{*/},
  moredelim=**[is][\color{green!60!black}]{/!}{!/},
  moredelim=**[is][\color{orange}]{/(}{)/},
  moredelim=[is][\color{red}]{/[}{]/},
  xleftmargin=1em,
}
\lstset{aboveskip=0.4ex,belowskip=0.4ex}


\begin{document}
%% TODO: say that correctness statements are in abstract

\newcommand{\showface}[1]{\includegraphics[height=2.3cm]{#1}}
\begin{frame}
  \titlepage

\begin{center}
  \showface{pictures/Francesco_Mecca.jpg}
  \showface{pictures/Gabriel_Scherer.jpg}
\end{center}
\end{frame}

\section{Motivation}

\begin{frame}
  \frametitle{Compiling pattern-matching}

  From pattern-matching to simple control-flow.

  Not simple: tradeoffs in code size vs. code speed.

  \vfill

  Bugs in the compiler: wrong-code production (no compile-time issue).

  Painful to detect and diagnose.

  \vfill

  In OCaml: % TODO: exceptions/extensible constructors, lazy+mutable

  \vfill

  We want to catch such bugs at compile-time.

  Translation-validation: check each source-target pair at compile-time.

  \vfill

  Work In Progress: simple patterns + \texttt{when}-guards.

  Cannot reproduce the bugs yet.

  Extensible approach (symbolic execution).
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example: source and target programs}
  Target program: exactly the \texttt{-drawlambda} output of the OCaml compiler.

\vfill

\begin{small}
  \hspace{-1em}
  \begin{minipage}{0.36\linewidth}
\begin{lstlisting}
type 'a option =
| None
| Some of 'a

let mm test ret input =
  match input with
  | Some x when $\bgalertcyan<3->{\text{test x}}$ -> $\bgalert<3->{\text{ret x}}$
  | Some 42 -> $\bgalert<3->{\text{ret 42}}$
  | _ -> $\bgalert<3->{\text{ret 0}}$
\end{lstlisting}
  \end{minipage}
  \hfill\pause
  \begin{minipage}{0.64\linewidth}
\begin{lstlisting}
(mm =
  (function test ret input
    (catch
      (if input
        (let (x =a (field 0 input))
          (if $\bgalertcyan<3->{\text{(apply test x)}}$
            $\bgalert<3->{\text{(apply ret x)}}$
            (if (!= x 42)
              (exit 1)
              $\bgalert<3->{\text{(apply ret 42))}}$))
        (exit 1))
    with (1)
      $\bgalert<3->{\text{(apply ret 0)}}$)))
\end{lstlisting}
  \end{minipage}
\end{small}

\pause\vfill
Arbitrary expressions (``blackboxes'') only in guards and leaves.

\pause\vfill

Use the compiler as an oracle on those;
check equivalence on the rest.
\end{frame}

\begin{frame}[fragile]
\frametitle{Approach}

\vfill
\begin{center}
\begin{tikzcd}[sep=8em]
  \text{source (patterns)}
  \arrow[d, "\text{decomposition}"]
&
  \text{target (ifs)}
  \arrow[d, "\text{symbolic execution}"]
\\
  \text{source decision tree}
  \arrow[r, Leftrightarrow, "\text{tree equivalence}"]
&
  \text{target decision tree}
\end{tikzcd}
\end{center}
\vfill

\end{frame}

\begin{frame}[fragile]
  \frametitle{Common representation: decision trees}
\begin{lstlisting}
match input with
| Some x when test x -> ret x
| Some 42 -> ret 42
| _ -> ret 0
\end{lstlisting}

\vfill\pause

\begin{lstlisting}[columns=fixed]
    Switch(Root)
    / None    \ Some
   /           \
  Leaf        Guard
[](ret 0)     [x = Root.0](test x)
              / true        \ false
            Leaf           Switch(Root.0)
      [x = Root.0](ret x)   / 42     \ _
                          Leaf       Leaf
                          [](ret 42) [](ret 0)
\end{lstlisting}

\vfill\pause

Source decision trees test language-level values (\texttt{None}, \texttt{Some}).

Target decision trees test low-level representations (\texttt{int 0}, \texttt{tag 0}).
\end{frame}

\begin{frame}
  \frametitle{Equivalence checking: Blackboxes}
  We assume that every pair (source blackbox, target blackbox) is are correctly emitted
  by the compiler and are equivalent as such. \\
  The compiler acts as an oracle. \\
  The rest of the program is compiled into a simpler representation on which we do equivalence checking. 

\end{frame}

\begin{frame}[fragile]
  \frametitle{Source programs}
  A source program is made by OCaml pattern matching statements of the following form:
  \begin{lstlisting}
    match value with
    | pattern -> result
    | pattern when guard -> result
    ...
  \end{lstlisting}
  The prototype at the moment doesn't support strings, extensible variants and floats. 
\end{frame}
\begin{frame}[fragile]
  \frametitle{Source programs: Examples}
  \begin{small}
    \hspace{-1em}
    %% Here I don't explicitly state that we use the shortcut of observe and guard
    %% external observe : 'a -> 'b = "observe"
    %% external guard : 'a -> 'b = "guard"
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
        let mm li = match li with
        | [] -> (0, None)
        | x::[] -> (1, Some x)
        | x::y::_ when x = y -> (2, Some y)

        type k1 = K1 of int
        type k2 = K2 of int * int
        let mm = function
        | (K1 1, _) -> 1
        | (K1 1, K2 (2, 2)) -> 1 2
        | _ -> 0
      \end{lstlisting}
    \end{minipage}
    \hfill
  \end{small}
  \pause
\end{frame}

\begin{frame}[fragile]
  \frametitle{Target programs}
  The target programs include the following Lambda constructs:
  \texttt{let, if, switch, Match\_failure, catch, exit, field} and
  various comparison operations, guards. \\
  The Lambda target language is discussed with more details in the \href{https://www.cl.cam.ac.uk/~sd601/papers/malfunction.pdf}{Malfunction paper}.
\end{frame}
\begin{frame}[fragile]
  \frametitle{Target programs: example}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
(setglobal example1!
  (let
    (mm/82 =
       (function li/83
         (catch
           (if li/83
             (let (*match*/90 =a (field 1 li/83) x/84 =a (field 0 li/83))
               (if *match*/90
                 (let
                   (x/85 =a x/84
                    *match*/91 =a (field 1 *match*/90)
                    y/86 =a (field 0 *match*/90))
                   (if (apply (guard x/85) y/86)
                     (makeblock 0 (int,*) 2 (makeblock 0 y/86))
                     (exit 1)))
                 (makeblock 0 (int,*) 1 (makeblock 0 x/84))))
             ([0: 0 0a]))
          with (1)
           (raise
             (makeblock 0 (global Match_failure/18!) [0: "example1.ml" 4 12])))))
    (makeblock 0 mm/82)))
      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Target programs: example} %% Simple_k.lambda
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
(setglobal example2!
  (let
    (mm/85 =
       (function param/86
         (let (*match*/91 =a (field 0 param/86))
           (catch
             (let (*match*/92 =a (field 0 *match*/91))
               (if (!= *match*/92 1) (exit 1)
                 (let (*match*/93 =a (field 1 param/86)) 1)))
            with (1) (let (*match*/94 =a (field 1 param/86)) 0)))))
    (makeblock 0 mm/85)))
      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}

%%% Time for decision trees
\begin{frame}
  \frametitle{Decision Trees}
  Source and target programs are translated into a common representation: \emph{decision trees}.
\end{frame}

%%% Here we show line by line how the previous examples gets translated into a decision tree
\begin{frame}[fragile]
  \frametitle{Decision Trees}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
        let mm li = match li with
        | [] -> (0, None)
        | ...
        | ...
      \end{lstlisting}
      \hrulefill
      \begin{lstlisting}
        Switch on AcRoot: Nil
             \
           Leaf: Tuple[2](Int 0, Variant None)
      \end{lstlisting}
      %% We should highlight that we switch on the accessor
    \end{minipage}
  \end{small}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decision Trees}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
        let mm li = match li with
        | ...
        | x::[] -> (1, Some x)
        | ...
      \end{lstlisting}
      \hrulefill
      \begin{lstlisting}
        Switch on AcRoot: Cons
            \
            Switch on AcRoot.1: Nil
              \
              Leaf: Tuple[2](Int 1, Variant (Some AcRoot.0))
      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}
 %% Now the guard
\begin{frame}[fragile]
  \frametitle{Decision Trees}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
        let mm li = match li with
        | ...
        | ...
        | x::y::_ when x = y -> (2, Some y)
      \end{lstlisting}
      \hrulefill
      \begin{lstlisting}
        Switch on AcRoot: Cons
            \
            Switch on AcRoot.1: Cons
              \
              Leaf: Tuple[2](Int 1, Variant (Some AcRoot.0))
                \
                Switch on AcRoot.1.1:
                        |
                Guard (AcRoot.0, AcRoot.1.0)
                        |
(guard is true) Leaf: Tuple[2] (Int 2, Variant (Some AcRoot.1.0))
                        |
(guard is false) Match Failure
      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decision Trees}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
(setglobal example1!
  (let
    (mm/82 =
       (function li/83
         (catch
            (if li/83
              ...
             ([0: 0 0a]))
      \end{lstlisting}
      \hrulefill
      \begin{lstlisting}
                     ...
                       \
        Switch ( var:AcRoot=li/83; domain={Int 0}) =
           Leaf=Constructor:{tag=0; args=Constant:0, Constant:0}
      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Decision Trees}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
     ...
(if li/83
  (let (*match*/90 =a (field 1 li/83) x/84 =a (field 0 li/83))
    (if *match*/90
     ...
     (makeblock 0 (int,*) 1 (makeblock 0 x/84))))
     ...
      \end{lstlisting}
      \hrulefill
      \begin{lstlisting}
...
  \
  Switch on var:AcRoot=li/83, domain={Int [-\inf -1] [1; +\inf] \vee Tag _} =
    \
    Switch ({ var=AcField(1 AcRoot=li/83); dom=Int 0; }) =
     \
     Leaf:
     VConstructor:{tag=0; args=VConstant:1,
       VConstructor:{tag=0; args=VAccessor:AcField (0 AcRoot li/83}}

      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decision Trees}
  \begin{small}
    \hspace{-1em}
    \begin{minipage}{0.36\linewidth}
      \begin{lstlisting}
        ...
        (if (apply (guard x/85) y/86)
          (makeblock 0 (int,*) 2 (makeblock 0 y/86))
          (exit 1)))
        ...
        with (1)
         (raise
           (makeblock 0 (global Match_failure/18!) [0: "example1.ml" 4 12])))))
      \end{lstlisting}
      \hrulefill
      \begin{lstlisting}
...
  \
  Guard (VAccessor:AcRoot x/84,
         VAccessor:AcField (0, AcField (1, AcRoot li/83))):
          |
     guard(true) = Leaf: ...
          |
     guard(false) = Match Failure
      \end{lstlisting}
    \end{minipage}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Related Work}
  %% TODO
\end{frame}

%%% table of contents
\begin{frame}
  \frametitle{Outline}
  \tableofcontents
\end{frame}

\end{document}

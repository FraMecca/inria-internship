* First blackboard

** Definitions

Translation to constraint trees:

  [|_|]ₛ : Source Terms -> Source Constraint Trees
  [|_|]ₜ : Target Terms -> Target Constraint Trees

Running a {program, constraint tree} against an input

  result r ::= guard list * (Match bb | NoMatch)
  guard := bb
  (same blackboxes 'bb' for source and target programs and constraint trees)

  tₛ(vₛ) → r
  tₜ(vₜ) → r

  Cₛ(vₛ) → r
  Cₜ(vₜ) → r

Equivalence of values, programs and constraint trees:

  vₛ ≃ vₜ    (TODO define, this talks about the representation of source values in the target)
  tₛ ≃ tₜ := (∀vₛ≃vₜ, tₛ(vₛ)=tₜ(vₜ))
  Cₛ ≃ Cₜ := (∀vₛ≃vₜ, Cₛ(vₛ)=Cₜ(vₜ))

Our equivalence algorithm on constraint trees:

  equiv Cₛ Cₜ → Yes | No(vₛ,vₜ)

  (Yes: equivalent, No: here is a pair of inputs as counter-example)

** Statements

Theorem: Correctness of translation to constraint trees:

  ∀vₛ, tₛ(vₛ) = [|tₛ|]ₛ(vₛ)
  ∀vₜ, tₜ(vₜ) = [|tₜ|]ₜ(vₜ)

Theorem: Correctness of the equivalence of constraint trees

  (equiv Cₛ Cₜ = Yes)  ⇔  (Cₛ ≃ Cₜ)

  Auxiliary Lemmas:
    (equiv Cₛ Cₜ = Yes)        ⇒   (Cₛ ≃ Cₜ)
    (equiv Cₛ Cₜ = No(vₛ,vₜ)   ⇒   vₛ≃vₜ ∧ Cₛ(vₛ)≠Cₜ(vₜ)
  
Corollary (our main result):
  (equiv [|tₛ|]ₛ [|tₜ|]ₜ = Yes)  ⇔  tₛ ≃ tₜ


*** Draft of proof for equivalence between constraint trees and source/target programs

tₛ      ::= (p → bb)ⁱ  # i ∈ I
p       ::= | K(pᵢ)ⁱ, i ∈ I | (p|q) | n ∈ ℕ        # t should be T in latex
tₜ      ::= if condₜ tₜ tₜ | let x = eₜ in tₜ | switch((pₜᵢ → tₜᵢ)ⁱ tₜ? | catch(tₜ, l(yᵢ)ⁱ  → tₜ) | exit l (eₜᵢ)ⁱ
                 i ∈ I
condₜ   ::= eₜ bop n eₜ::=x | eₜ.n

Cₛ      ::= Leaf bb | Node(a, (Kᵢ → Cᵢ)ⁱ , C?) # i ∈ S
a       ::= Here | n.a
vₛ      ::= K(vᵢ)ⁱ | n ∈ ℕ   # i ∈ I


[|_|] STerms -> STrees

SMatrix mₛ := (aᵢ)ʲ, ((pᵢⱼ)ʲ → bbᵢ)ⁱ  # i ∈ I j ∈ Jᵢ # i columns, j rows, order matters
[|((pᵢ → bbᵢ)ⁱ|] := [| (Root), ((pᵢ → bbᵢ)ⁱ |] # i ∈ I
[| ∅, (∅ → bbᵢ)ⁱ |] := Leaf bbᵢ where i := min(I)

[| aⱼ, rⱼ |] := (cols(mₛ)>1) := let Grups((aⱼ)ᴵ,(rᵢ)ⁱ) be (Kₖ → mₖ), m_{wildcards)
                 Node( aₘᵢₙ₍ⱼ₎, Kₖ → [| mₖ |]ᵏ, [|m_{wildcards}|])
[| (aⱼ)ʲ, ∅ |] := Unreachable


**** Sterms -> STrees

SMatrix mₛ := (aⱼ)ʲ, ((pᵢⱼ)ʲ → bbᵢ)ⁱ
∀(vⱼ)ʲ, mₛ(vⱼ)ʲ = [|mₛ|](vⱼ)ʲ

v(Here) = v
K(vᵢ)ⁱ(k.a) = vₖ(a) if k ∈ [0;n[

We also said that
(Leaf bb)(v) := Match bb
(Node(a, (kᵢ → cᵢ)ⁱ, c_{fallback}))(v)
    let v(a) be K(vⱼ)ʲ
        if k ∈ {Kᵢ}ⁱ then  C_{min{i}|k=kᵢ}(v)
        else c_{fallback}(v)




*** In-progress blackboard notes on the proof of the non-base case

Correct(m) := ∀v, (vᵢ)ⁱ = v(aᵢ)ⁱ => m(vᵢ)ⁱ = [|m|](v)


  (∀m', |m'| < |m| => Correct(m')) => Correct(m)
  We are given: v, (vᵢ)ⁱ = v(aᵢ)ⁱ
  Goal: m(vᵢ) = [|m|](v)

  (0 = min(I))
  case analysis on v₀: K(v'ₖ)ᵏ


  Groups : (m) -> (Kₖ → mₖ)ᵏ, m_wildcard

  ∀(vᵢ)ⁱ, (m)(vᵢ)ⁱ =
    mₖ((v'ₕ)ʰ, (vᵢ)^{i>0})
    where v₀ is Kₖ(v'ₕ)ʰ for some k
